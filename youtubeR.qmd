% Generated by pkgslides: do not edit by hand
---
title: youtubeR
subtitle: 0.0.0.9000
format:
  revealjs:
    theme: default
    navigation-mode: vertical
    self-contained: true
    scrollable: true
---

## An Interface to the YouTube API

::: {.r-fit-text}

Manage YouTube videos from R.

:::

```{r}
#| echo: false
library(youtubeR)
```

# aaa_authentication.R

## Visit Google Cloud Credentials page

::: {.r-fit-text}

- **Topic:** `browse_gc_credentials`

- **Description:** Launch the Google Cloud "Credentials" page (where you can configure OAuth 2.0
Clients). After you configure a client, copy/paste the Client ID and Client
Secret into the `YOUTUBE_CLIENT_ID` and `YOUTUBE_CLIENT_SECRET` environment
variables. We recommend placing these environment variables in your
`.Renviron` file.

- **Return:** The url of the "Credentials" page, invisibly.

:::


## Parameters

::: {.r-fit-text}



:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
gc_credentials_url <- browse_gc_credentials()
# Copy/paste values from your client.
Sys.setenv(YOUTUBE_CLIENT_ID = "12345-ab12c.apps.googleusercontent.com")
Sys.setenv(YOUTUBE_CLIENT_SECRET = "ABCD-eFg_H")
```

:::


## Code

::: {.r-fit-text}

```{.r}
browse_gc_credentials <- function() {
  gc_creds_url <- "https://console.cloud.google.com/apis/credentials"
  if (rlang::is_interactive()) { # nocov start
    utils::browseURL(gc_creds_url)
  } # nocov end
  return(invisible(gc_creds_url))
}
```

:::

## Check for YouTube client environment variables

::: {.r-fit-text}

- **Topic:** `yt_has_client_envvars`

- **Description:** Reports whether YouTube client environment variables are set (or, if
arguments are provided, check that they have characters).

- **Return:** A logical indicating whether the variables are available.

:::


## Parameters

::: {.r-fit-text}

- `client_id`: A [Google Cloud OAuth
2.0](https://console.cloud.google.com/apis/credentials) client ID. We
recommend you save it as an environment variable, `YOUTUBE_CLIENT_ID`.
- `client_secret`: A [Google Cloud OAuth
2.0](https://console.cloud.google.com/apis/credentials) client secret. We
recommend you save it as an environment variable, `YOUTUBE_CLIENT_SECRET`.

:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
yt_has_client_envvars()
yt_has_client_envvars("an_id_string", "a_secret_string")
```

:::


## Code

::: {.r-fit-text}

```{.r}
yt_has_client_envvars <- function(client_id = Sys.getenv("YOUTUBE_CLIENT_ID"),
                                  client_secret = Sys.getenv(
                                    "YOUTUBE_CLIENT_SECRET"
                                  )) {
  return(nchar(client_id) && nchar(client_secret))
}
```

:::

## Construct a YouTube OAuth client

::: {.r-fit-text}

- **Topic:** `yt_construct_client`

- **Description:** Builds the OAuth client object for google apis.

- **Return:** An [httr2::oauth_client()] object.

:::


## Parameters

::: {.r-fit-text}



:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
client <- yt_construct_client()
```

:::


## Code

::: {.r-fit-text}

```{.r}
yt_construct_client <- function(client_id = Sys.getenv("YOUTUBE_CLIENT_ID"),
                                client_secret = Sys.getenv(
                                  "YOUTUBE_CLIENT_SECRET"
                                )) {
  if (!yt_has_client_envvars(client_id, client_secret)) {
    cli::cli_abort(
      "Please provide a YOUTUBE_CLIENT_ID and YOUTUBE_CLIENT_SECRET.",
      class = "missing_youtube_client"
    )
  }

  return(
    httr2::oauth_client(
      id = client_id,
      token_url = "https://oauth2.googleapis.com/token",
      secret = client_secret,
      auth = "header",
      name = "youtube_data_api"
    )
  )
}
```

:::

## Authenticate with a YouTube OAuth client

::: {.r-fit-text}

- **Topic:** `yt_authenticate`

- **Description:** Load or generate a YouTube OAuth token for use in the other functions in
this package. The primary use of this function is to cache values early in a
script (so the user can walk away). Otherwise the other functions in this
package will prompt for authentication when needed. Once the values are
cached, the rest of this package will use them by default for that client.

- **Return:** A YouTube OAuth token, invisibly.

:::


## Parameters

::: {.r-fit-text}

- `client`: A YouTube OAuth client created with [yt_construct_client()].
- `force`: A logical indicating whether to force a refresh of the token.
- `refresh_token`: A refresh token associated with this `client`. This
parameter exists primarily for testing. If you wish to provide a refresh
token (for example, for automated processes), we recommend setting a
`YOUTUBE_REFRESH_TOKEN` environment variable.

:::



## Code

::: {.r-fit-text}

```{.r}
yt_authenticate <- function(client = yt_construct_client(),
                            force = FALSE,
                            refresh_token = NULL) {
  if (force) {
    if (is.null(refresh_token)) {
      token <- NULL
    } else {
      token <- .yt_refresh_token(client, refresh_token)
    }
  } else {
    # This tries everything that we can try without bugging the user.
    token <- .get_token_noninteractive(client, refresh_token)
  }

  if (rlang::is_interactive() && is.null(token)) { # nocov start
    token <- httr2::oauth_flow_auth_code(
      client = client,
      auth_url = "https://accounts.google.com/o/oauth2/v2/auth",
      scope = "https://www.googleapis.com/auth/youtube"
    )

    the[[rlang::hash(client)]] <- token
  } # nocov end

  return(invisible(token))
}
```

:::

## Retrieve a YouTube OAuth token if possible

::: {.r-fit-text}

- **Topic:** `.get_token_noninteractive`

- **Return:** A YouTube OAuth token, or `NULL`.

:::


## Parameters

::: {.r-fit-text}

- `refresh_token`: A refresh token associated with this `client`.

:::



## Code

::: {.r-fit-text}

```{.r}
.get_token_noninteractive <- function(client, refresh_token = NULL) {
  key <- rlang::hash(client)
  if (!is.null(the[[key]])) {
    if (!.is_expired(the[[key]]$expires_at)) {
      return(the[[key]])
    }
  }

  return(.yt_refresh_token(client, refresh_token = refresh_token))
}
```

:::

## Refresh a YouTube OAuth token

::: {.r-fit-text}

- **Topic:** `.yt_refresh_token`

:::


## Parameters

::: {.r-fit-text}



:::



## Code

::: {.r-fit-text}

```{.r}
.yt_refresh_token <- function(client, refresh_token = NULL) {
  refresh_token <- refresh_token %||%
    the[[rlang::hash(client)]]$refresh_token %||%
    Sys.getenv("YOUTUBE_REFRESH_TOKEN")
  if (nchar(refresh_token)) {
    return(httr2::oauth_flow_refresh(client, refresh_token))
  }
  return(NULL)
}
```

:::

## YouTube OAuth authentication

::: {.r-fit-text}

- **Topic:** `.yt_req_auth`

- **Description:** This function is the main way authentication is handled in this package. It
tries to find a token non-interactively if possible, but bothers the user if
necessary.

- **Return:** A [httr2::request()] with oauth authentication information.

:::


## Parameters

::: {.r-fit-text}

- `request`: A [httr2::request()].
- `cache_key`: If you are authenticating with multiple users using the same
client, use this key to differentiate between those users.
- `token`: A YouTube API OAuth token, or the `access_token` string from
such a token. We recommend that you instead supply a `client`, in which
case an appropriate token will be located if possible.

:::



## Code

::: {.r-fit-text}

```{.r}
.yt_req_auth <- function(request,
                         client = yt_construct_client(),
                         cache_disk = getOption("yt_cache_disk", FALSE),
                         cache_key = getOption("yt_cache_key", NULL),
                         token = NULL) {
  if (!is.null(token)) {
    if (inherits(token, "httr2_token")) {
      if (!.is_expired(token[["expires_at"]])) {
        return(httr2::req_auth_bearer_token(request, token[["access_token"]]))
      }
    } else {
      return(httr2::req_auth_bearer_token(request, token))
    }
  }

  # If cache_disk is TRUE, we need to let httr2 deal with things; we can't dig
  # into that cache without digging into unexported httr2 functions (and thus
  # implementation might change).
  if (!cache_disk) {
    token <- .get_token_noninteractive(client)
    if (!is.null(token)) {
      return(httr2::req_auth_bearer_token(request, token$access_token))
    }
  }

  return(
    httr2::req_oauth_auth_code(
      req = request,
      client = client,
      auth_url = "https://accounts.google.com/o/oauth2/v2/auth",
      scope = "https://www.googleapis.com/auth/youtube",
      cache_disk = cache_disk,
      cache_key = cache_key
    )
  )
}
```

:::

# aaa_requests.R

## Call the YouTube API

::: {.r-fit-text}

- **Topic:** `yt_call_api`

- **Description:** If you use this function, please [open an issue in the youtubeR GitHub
repository](https://github.com/kevin-m-kent/youtubeR/issues) describing your
use case. We intend to wrap all endpoints such that this function will not be
necessary for users.

- **Return:** The result of the call.

:::


## Parameters

::: {.r-fit-text}

- `endpoint`: The path to an endpoint. Optionally, a list with the path
plus variables to [glue::glue()] into the path.
- `query`: An optional list of parameters to pass in the query portion of
the request.
- `body`: An optional list of parameters to pass in the body portion of the
request.
- `method`: If the method is something other than GET or POST, supply it.
Case is ignored.
- `base_url`: Which family of URLs to use. Almost everything will use the
default basic URL.

:::



## Code

::: {.r-fit-text}

```{.r}
yt_call_api <- function(endpoint,
                        query = NULL,
                        body = NULL,
                        method = NULL,
                        client = yt_construct_client(),
                        cache_disk = getOption("yt_cache_disk", FALSE),
                        cache_key = getOption("yt_cache_key", NULL),
                        token = NULL,
                        base_url = c(
                          "basic", "upload", "resumable_upload"
                        )) {
  request <- .prepare_request(
    endpoint = endpoint,
    query = query,
    body = body,
    method = method,
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token,
    base_url = base_url
  )
  response <- httr2::req_perform(request)

  return(.parse_response(response))
}
```

:::

## Combine request pieces

::: {.r-fit-text}

- **Topic:** `.prepare_request`

- **Return:** A request ready to perform.

:::


## Parameters

::: {.r-fit-text}



:::



## Code

::: {.r-fit-text}

```{.r}
.prepare_request <- function(endpoint,
                             query = NULL,
                             body = NULL,
                             method = NULL,
                             client = yt_construct_client(),
                             cache_disk = getOption("yt_cache_disk", FALSE),
                             cache_key = getOption("yt_cache_key", NULL),
                             token = NULL,
                             base_url = c(
                               "basic", "upload", "resumable_upload"
                             )) {
  base_url <- rlang::arg_match(base_url)
  base_url <- .base_url[[base_url]]
  request <- httr2::request(base_url)
  endpoint <- rlang::exec(glue::glue, !!!endpoint)
  request <- httr2::req_url_path_append(request, endpoint)

  if (!is.null(query)) {
    query <- .remove_missing(query)
    if (length(query)) {
      names(query) <- snakecase::to_lower_camel_case(names(query))
      request <- httr2::req_url_query(request, !!!query)
    }
  }
  if (!is.null(body)) {
    body <- .remove_missing(body)
    body <- .prepare_body(body)
    if (length(body)) {
      request <- .add_body(request, body)
    }
  }
  if (!is.null(method)) {
    request <- httr2::req_method(request, method)
  }

  return(
    .yt_req_auth(
      request = request,
      client = client,
      cache_disk = cache_disk,
      cache_key = cache_key,
      token = token
    )
  )
}
```

:::

## Remove missing arguments

::: {.r-fit-text}

- **Topic:** `.remove_missing`

- **Return:** The list without missing parameters.

:::


## Parameters

::: {.r-fit-text}

- `arg_list`: A list of arguments, each of which should be wrapped in
`rlang::maybe_missing()`.

:::



## Code

::: {.r-fit-text}

```{.r}
.remove_missing <- function(arg_list) {
  arg_present <- !purrr::map_lgl(
    arg_list,
    rlang::is_missing
  )
  # QUESTION: I *think* I can simplify this now since we auto-set the body type.
  # Experiment to see if this ever fails.
  if (all(class(arg_list) == "list")) {
    return(arg_list[arg_present])
  } else { # nocov start
    stop("In the .remove_missing piece you thought you could remove.")
    return(
      structure(
        arg_list[arg_present],
        # Preserve special classes!
        class = class(arg_list)
      )
    )
  } # nocov end
}
```

:::

## Prepare the body of a call

::: {.r-fit-text}

- **Topic:** `.prepare_body`

- **Return:** A prepared body list object with a "json" or "multipart" subclass.

:::


## Parameters

::: {.r-fit-text}

- `body`: An object to use as the body of the request. If any component of
the body is a path, pass it through [fs::path()] or otherwise give it the
class "fs_path" to indicate that it is a path.

:::



## Code

::: {.r-fit-text}

```{.r}
.prepare_body <- function(body,
                          mime_type = NULL) {
  # COMBAK: We should probably do some sort of recursive map to make sure all
  # names at depth are in camelCase.

  body <- .compact(body)
  if (rlang::is_named(body)) {
    names(body) <- snakecase::to_lower_camel_case(names(body))
  }
  if (purrr::some(body, function(x) inherits(x, "fs_path"))) {
    body <- purrr::map(body, .prepare_body_part, mime_type)
    class(body) <- c("multipart", "list")
    return(body)
  } else {
    class(body) <- c("json", "list")
    return(body)
  }
}
```

:::

## Prepare a multipart body part

::: {.r-fit-text}

- **Topic:** `.prepare_body_part`

- **Return:** A character or raw vector to post.

:::


## Parameters

::: {.r-fit-text}

- `body_part`: One piece of a multipart body.
- `mime_type`: A character scalar indicating the mime type of any files
present in the body. Some APIs are ok leaving this at NULL for them to
guess.

:::



## Code

::: {.r-fit-text}

```{.r}
.prepare_body_part <- function(body_part, mime_type = NULL) {
  if (rlang::is_named(body_part)) {
    names(body_part) <- snakecase::to_lower_camel_case(names(body_part))
  }
  if (inherits(body_part, "fs_path")) {
    return(curl::form_file(body_part, type = mime_type))
  }
  return(curl::form_data(
    jsonlite::toJSON(body_part, auto_unbox = TRUE),
    type = "application/json"
  ))
}
```

:::

# aaa_utils.R

## Datetime vectors

::: {.r-fit-text}

- **Topic:** `datetime`

- **Description:** Create an object of type "POSIXct". This function is used to provide a
length-0 placeholder value in function definitions.

- **Return:** A length-0 POSIXct object.

:::


## Parameters

::: {.r-fit-text}



:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
datetime()
```

:::


## Code

::: {.r-fit-text}

```{.r}
datetime <- function() {
  return(as.POSIXct(integer()))
}
```

:::

## Discard empty elements

::: {.r-fit-text}

- **Topic:** `.compact`

- **Description:** Discard empty elements in nested lists.

- **Return:** The list, minus empty elements and branches.

:::


## Parameters

::: {.r-fit-text}

- `lst`: A (nested) list to filter.
- `depth`: The current recursion depth.
- `max_depth`: The maximum recursion depth.

:::



## Code

::: {.r-fit-text}

```{.r}
.compact <- function(lst, depth = 1, max_depth = 20) {
  if (is.list(lst) && depth <= max_depth) {
    lst <- purrr::map(
      lst, .compact,
      depth = depth + 1,
      max_depth = max_depth
    )
  }
  return(purrr::compact(lst))
}
```

:::

## Smush a string to a comma-separated list

::: {.r-fit-text}

- **Topic:** `.str2csv`

- **Return:** A character scalar like "this,that".

:::


## Parameters

::: {.r-fit-text}

- `string`: A character vector to smush.

:::



## Code

::: {.r-fit-text}

```{.r}
.str2csv <- function(string) {
  return(paste(string, collapse = ","))
}
```

:::

## Stringify the names of a list

::: {.r-fit-text}

- **Topic:** `.format_used_names`

- **Return:** A comma-separated character, such as "this,that".

:::


## Parameters

::: {.r-fit-text}

- `lst`: A named list object. This object will be compacted, and then the
names of any remaining components will be returned, as a comma-separated
list.

:::



## Code

::: {.r-fit-text}

```{.r}
.format_used_names <- function(lst) {
  names(lst) <- snakecase::to_lower_camel_case(names(lst))
  return(.str2csv(names(.compact(lst))))
}
```

:::

# channels.R

## Get my channel detail playlist ids

::: {.r-fit-text}

- **Topic:** `get_my_channel_detail_playlist_ids`

- **Description:** Get ids of playlists that contain details about the content of a channel.

- **Return:** The *contentDetails* object encapsulates information about the
channel's content.
| **Property** | **Class** | **Description** |
|:-------------|:----------|:----------------|
| watchHistory | character | The ID of the playlist that contains the channel's watch history. Use the playlistItems.insert and playlistItems.delete to add or remove items from that list. |
| likes | character | The ID of the playlist that contains the channel's liked videos. Use the playlistItems.insert and playlistItems.delete to add or remove items from that list. |
| favorites | character | The ID of the playlist that contains the channel's favorite videos. Use the playlistItems.insert and playlistItems.delete to add or remove items from that list. |
| watchLater | character | The ID of the playlist that contains the channel's watch later playlist. Use the playlistItems.insert and playlistItems.delete to add or remove items from that list. |
| uploads | character | The ID of the playlist that contains the channel's uploaded videos. Use the videos.insert method to upload new videos and the videos.delete method to delete previously uploaded videos. |

:::


## Parameters

::: {.r-fit-text}



:::



## Code

::: {.r-fit-text}

```{.r}
get_my_channel_detail_playlist_ids <- function(client = yt_construct_client(),
                                               cache_disk = getOption(
                                                 "yt_cache_disk", FALSE
                                               ),
                                               cache_key = getOption(
                                                 "yt_cache_key", NULL
                                               ),
                                               token = NULL) {
  res <- yt_call_api(
    endpoint = "channels",
    query = list(
      part = "contentDetails",
      mine = TRUE
    ),
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  # For now I'm just doing one quick "well that's weird" check. We should make
  # this more robust.
  if (length(res$items) != 1) { # nocov start
    cli::cli_abort(
      "Expected 1 channel$items, got {length(res$items)}.",
      class = "unexpected_items_length"
    )
  } # nocov end


  return(res$items[[1]]$contentDetails$relatedPlaylists)
}
```

:::

## Get Playlist Ids

::: {.r-fit-text}

- **Topic:** `get_upload_playlist_id`

- **Description:** Retrieves the upload playlist ids.

- **Return:** list of playlist ids for uploads

:::


## Parameters

::: {.r-fit-text}



:::



## Code

::: {.r-fit-text}

```{.r}
get_upload_playlist_id <- function(client = yt_construct_client(),
                                   cache_disk = getOption(
                                     "yt_cache_disk", FALSE
                                   ),
                                   cache_key = getOption(
                                     "yt_cache_key", NULL
                                   ),
                                   token = NULL) {
  return(
    get_my_channel_detail_playlist_ids(
      client = client,
      cache_disk = cache_disk,
      cache_key = cache_key,
      token = token
    )$uploads
  )
}
```

:::

# playlist_items.R

## Get playlist items

::: {.r-fit-text}

- **Topic:** `get_playlist_items`

- **Description:** Retrieve a list of items in a given playlist.

- **Return:** A list of videos, each of which has a videoId and a videoPublishedAt.

:::


## Parameters

::: {.r-fit-text}

- `playlist_id`: The ID of a playlist.
- `max_results`: The maximum number of results to return.

:::



## Code

::: {.r-fit-text}

```{.r}
get_playlist_items <- function(playlist_id,
                               max_results = 100,
                               client = yt_construct_client(),
                               cache_disk = getOption("yt_cache_disk", FALSE),
                               cache_key = getOption("yt_cache_key", NULL),
                               token = NULL) {
  res <- yt_call_api(
    endpoint = "playlistItems",
    query = list(
      part = "contentDetails",
      maxResults = max_results,
      playlistId = playlist_id
    ),
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  if (length(res$items)) {
    return(purrr::map(res$items, purrr::pluck, "contentDetails"))
  } else {
    return(NULL) # nocov
  }
}
```

:::

## Get playlist video ids

::: {.r-fit-text}

- **Topic:** `get_playlist_video_ids`

- **Description:** Retrieves video ids for a particular playlist.

- **Return:** A character vector of video ids.

:::


## Parameters

::: {.r-fit-text}



:::



## Code

::: {.r-fit-text}

```{.r}
get_playlist_video_ids <- function(playlist_id,
                                   max_results = 100,
                                   client = yt_construct_client(),
                                   cache_disk = getOption(
                                     "yt_cache_disk", FALSE
                                   ),
                                   cache_key = getOption(
                                     "yt_cache_key", NULL
                                   ),
                                   token = NULL) {
  playlist_items <- get_playlist_items(
    playlist_id,
    max_results,
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  return(
    purrr::map_chr(playlist_items, purrr::pluck, "videoId")
  )
}
```

:::

# videos.R

## Get video processing details

::: {.r-fit-text}

- **Topic:** `get_video_processing_details`

- **Description:** Retrieves the processing details for a vector of video IDs

- **Return:** A list of processing status details. processingStatus is probably of
most interest

:::


## Parameters

::: {.r-fit-text}

- `video_ids`: A character vector of video ids.

:::



## Code

::: {.r-fit-text}

```{.r}
get_video_processing_details <- function(video_ids,
                                         client = yt_construct_client(),
                                         cache_disk = getOption(
                                           "yt_cache_disk", FALSE
                                         ),
                                         cache_key = getOption(
                                           "yt_cache_key", NULL
                                         ),
                                         token = NULL) {
  result <- yt_call_api(
    endpoint = "videos",
    query = list(
      part = "processingDetails",
      id = .str2csv(video_ids)
    ),
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  if (length(result$items)) {
    # HACK: Technically these could come back in a different order, or be
    # missing some. We should dig into res$items[[x]]$id to match up to
    # video_ids.
    names(result$items) <- video_ids
    return(purrr::map(result$items, purrr::pluck, "processingDetails"))
  } else {
    # QUESTION: Is this possible? Probably handle in the response processing?
    return(NULL) # nocov
  }
}
```

:::

## Insert video

::: {.r-fit-text}

- **Topic:** `yt_videos_insert`

- **Description:** Inserts a new resource into this collection.

- **Return:** The id of the uploaded video.

:::


## Parameters

::: {.r-fit-text}

- `video_path`: (character scalar) Path to a video file to upload.
- `snippet`: Basic details about a video, including title, description,
uploader, thumbnails and category. See [yt_schema_video_snippet()] for
details.
- `localizations`: A list of named localizations objects. The localizations
object contains localized versions of the basic details about the video,
such as its title and description. The name should be a valid language key,
which is a [BCP-47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt) language
code. See [yt_schema_video_localization()] for details on the format for
each localization.
- `status`: Basic details about a video category, such as its localized
title. See [yt_schema_video_status()] for details.
- `recording_date`: (datetime scalar) The date and time when the video was
recorded.

:::



## Code

::: {.r-fit-text}

```{.r}
yt_videos_insert <- function(video_path,
                             snippet = yt_schema_video_snippet(),
                             localizations = list(),
                             status = yt_schema_video_status(),
                             recording_date = datetime(),
                             client = yt_construct_client(),
                             cache_disk = getOption("yt_cache_disk", FALSE),
                             cache_key = getOption("yt_cache_key", NULL),
                             token = NULL) {
  body <- list(
    metadata = list(
      snippet = snippet,
      localizations = localizations,
      status = status,
      recording_details = list(
        recording_date = recording_date
      )
    ),
    media = fs::path(video_path) # Signal that this is a file.
  )
  result <- yt_call_api(
    endpoint = "videos",
    query = list(part = .format_used_names(body$metadata)),
    body = body,
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token,
    base_url = "upload"
  )

  return(result$id)
}
```

:::

## Update video

::: {.r-fit-text}

- **Topic:** `yt_videos_update`

- **Description:** Updates an existing resource.

- **Return:** The id of the updated video.

:::


## Parameters

::: {.r-fit-text}

- `video_id`: (character scalar) The id parameter specifies the YouTube
video ID for the resource that is being updated In a video resource, the id
property specifies the video's ID.

:::



## Code

::: {.r-fit-text}

```{.r}
yt_videos_update <- function(video_id,
                             snippet = yt_schema_video_snippet(),
                             localizations = list(),
                             status = yt_schema_video_status(),
                             recording_date = datetime(),
                             client = yt_construct_client(),
                             cache_disk = getOption("yt_cache_disk", FALSE),
                             cache_key = getOption("yt_cache_key", NULL),
                             token = NULL) {
  # HACK: This body should be compared to the existing body for this video.
  # Missing pieces should be filled in from the existing body.
  body <- list(
    id = video_id,
    snippet = snippet,
    localizations = localizations,
    status = status,
    recording_details = list(
      recording_date = recording_date
    )
  )
  result <- yt_call_api(
    endpoint = "videos",
    query = list(part = .format_used_names(body[names(body) != "id"])),
    body = body,
    method = "PUT",
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  return(result$id)
}
```

:::

## Delete video

::: {.r-fit-text}

- **Topic:** `yt_videos_delete`

- **Description:** Deletes a resource.

- **Return:** The id of the deleted video.

:::


## Parameters

::: {.r-fit-text}

- `video_id`: (character scalar) The id parameter specifies the YouTube
video ID for the resource that is being deleted. In a video resource, the
id property specifies the video's ID.

:::



## Code

::: {.r-fit-text}

```{.r}
yt_videos_delete <- function(video_id,
                             client = yt_construct_client(),
                             cache_disk = getOption("yt_cache_disk", FALSE),
                             cache_key = getOption("yt_cache_key", NULL),
                             token = NULL) {
  result <- yt_call_api(
    endpoint = "videos",
    query = list(id = video_id),
    method = "DELETE",
    client = client,
    cache_disk = cache_disk,
    cache_key = cache_key,
    token = token
  )

  # QUESTION: Does this make sense? That ID isn't valid anymore. Maybe we SHOULD
  # return NULL?
  if (is.null(result)) {
    # This is the expectation so I'm treating this as not an error, and passing
    # through the video id.
    return(video_id)
  }

  # It shouldn't be possible for this to happen without some other error before
  # this, but be prepared in case it does.
  cli::cli_abort("Video delete failed.") # nocov
}
```

:::

# zzz_schemas.R

## Video snippet

::: {.r-fit-text}

- **Topic:** `yt_schema_video_snippet`

- **Description:** Basic details about a video, including title, description, uploader,
thumbnails and category.

- **Return:** A list with any non-zero-length properties.

:::


## Parameters

::: {.r-fit-text}

- `title`: (character scalar) The video's title.
- `description`: (character scalar) The video's description.
- `tags`: (character vector) A list of keyword tags associated with the
video. Tags may contain spaces.
- `category_id`: (character scalar) The YouTube video category associated
with the video.
- `default_language`: (character scalar) The language of the videos's
default snippet.

:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
yt_schema_video_snippet()
yt_schema_video_snippet(title = "An example video", tags = c("a", "b"))
```

:::


## Code

::: {.r-fit-text}

```{.r}
yt_schema_video_snippet <- function(title = character(),
                                    description = character(),
                                    tags = character(),
                                    category_id = character(),
                                    default_language = character()) {
  return(
    .compact(
      list(
        title = title,
        description = description,
        tags = tags,
        category_id = category_id,
        default_language = default_language
      )
    )
  )
}
```

:::

## Video status

::: {.r-fit-text}

- **Topic:** `yt_schema_video_status`

- **Description:** The status object contains information about the video's uploading,
processing, and privacy statuses.

- **Return:** A list with any non-zero-length properties.

:::


## Parameters

::: {.r-fit-text}

- `embeddable`: (logical) This value indicates if the video can be embedded
on another website.
- `license`: (factor scalar) The video's license. values: youtube,
creativeCommon
- `privacy_status`: (factor scalar) The video's privacy status. values:
public, unlisted, private
- `public_stats_viewable`: (logical) This value indicates if the extended
video statistics on the watch page can be viewed by everyone. Note that the
view count, likes, etc will still be visible if this is disabled.
- `publish_at`: (datetime scalar) The date and time when the video is
scheduled to publish. It can be set only if the privacy status of the video
is private.
- `self_declared_made_for_kids`: (logical) Whether the video is made for
kids.

:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
yt_schema_video_status()
yt_schema_video_status(embeddable = TRUE)
```

:::


## Code

::: {.r-fit-text}

```{.r}
yt_schema_video_status <- function(embeddable = logical(),
                                   license = character(),
                                   privacy_status = character(),
                                   public_stats_viewable = logical(),
                                   publish_at = datetime(),
                                   self_declared_made_for_kids = logical()) {
  return(
    .compact(
      list(
        embeddable = embeddable,
        license = license,
        privacy_status = privacy_status,
        public_stats_viewable = public_stats_viewable,
        publish_at = publish_at,
        self_declared_made_for_kids = self_declared_made_for_kids
      )
    )
  )
}
```

:::

## Video localization

::: {.r-fit-text}

- **Topic:** `yt_schema_video_localization`

- **Description:** Localized versions of certain video properties (e.g. title).

- **Return:** A list with any non-zero-length properties.

:::


## Parameters

::: {.r-fit-text}

- `description`: (character scalar) Localized version of the video's
description.
- `title`: (character scalar) Localized version of the video's title.

:::


## Examples

::: {.r-fit-text}

```{r}
#| echo: true
yt_schema_video_localization()
yt_schema_video_localization(description = "A description.")
```

:::


## Code

::: {.r-fit-text}

```{.r}
yt_schema_video_localization <- function(description = character(),
                                         title = character()) {
  return(
    .compact(
      list(
        description = description,
        title = title
      )
    )
  )
}
```

:::
